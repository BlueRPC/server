// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package worker

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BluetoothClassicServiceClient is the client API for BluetoothClassicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BluetoothClassicServiceClient interface {
	// Start a device scan of duration "time"
	Scan(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (*ScanResult, error)
	// Enable background scanning with a reporting interval of "time"
	ScanBackground(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (BluetoothClassicService_ScanBackgroundClient, error)
}

type bluetoothClassicServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBluetoothClassicServiceClient(cc grpc.ClientConnInterface) BluetoothClassicServiceClient {
	return &bluetoothClassicServiceClient{cc}
}

func (c *bluetoothClassicServiceClient) Scan(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (*ScanResult, error) {
	out := new(ScanResult)
	err := c.cc.Invoke(ctx, "/worker.BluetoothClassicService/Scan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothClassicServiceClient) ScanBackground(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (BluetoothClassicService_ScanBackgroundClient, error) {
	stream, err := c.cc.NewStream(ctx, &BluetoothClassicService_ServiceDesc.Streams[0], "/worker.BluetoothClassicService/ScanBackground", opts...)
	if err != nil {
		return nil, err
	}
	x := &bluetoothClassicServiceScanBackgroundClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BluetoothClassicService_ScanBackgroundClient interface {
	Recv() (*ScanResult, error)
	grpc.ClientStream
}

type bluetoothClassicServiceScanBackgroundClient struct {
	grpc.ClientStream
}

func (x *bluetoothClassicServiceScanBackgroundClient) Recv() (*ScanResult, error) {
	m := new(ScanResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BluetoothClassicServiceServer is the server API for BluetoothClassicService service.
// All implementations must embed UnimplementedBluetoothClassicServiceServer
// for forward compatibility
type BluetoothClassicServiceServer interface {
	// Start a device scan of duration "time"
	Scan(context.Context, *DeviceScan) (*ScanResult, error)
	// Enable background scanning with a reporting interval of "time"
	ScanBackground(*DeviceScan, BluetoothClassicService_ScanBackgroundServer) error
	mustEmbedUnimplementedBluetoothClassicServiceServer()
}

// UnimplementedBluetoothClassicServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBluetoothClassicServiceServer struct {
}

func (UnimplementedBluetoothClassicServiceServer) Scan(context.Context, *DeviceScan) (*ScanResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Scan not implemented")
}
func (UnimplementedBluetoothClassicServiceServer) ScanBackground(*DeviceScan, BluetoothClassicService_ScanBackgroundServer) error {
	return status.Errorf(codes.Unimplemented, "method ScanBackground not implemented")
}
func (UnimplementedBluetoothClassicServiceServer) mustEmbedUnimplementedBluetoothClassicServiceServer() {
}

// UnsafeBluetoothClassicServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BluetoothClassicServiceServer will
// result in compilation errors.
type UnsafeBluetoothClassicServiceServer interface {
	mustEmbedUnimplementedBluetoothClassicServiceServer()
}

func RegisterBluetoothClassicServiceServer(s grpc.ServiceRegistrar, srv BluetoothClassicServiceServer) {
	s.RegisterService(&BluetoothClassicService_ServiceDesc, srv)
}

func _BluetoothClassicService_Scan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceScan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothClassicServiceServer).Scan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothClassicService/Scan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothClassicServiceServer).Scan(ctx, req.(*DeviceScan))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothClassicService_ScanBackground_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeviceScan)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BluetoothClassicServiceServer).ScanBackground(m, &bluetoothClassicServiceScanBackgroundServer{stream})
}

type BluetoothClassicService_ScanBackgroundServer interface {
	Send(*ScanResult) error
	grpc.ServerStream
}

type bluetoothClassicServiceScanBackgroundServer struct {
	grpc.ServerStream
}

func (x *bluetoothClassicServiceScanBackgroundServer) Send(m *ScanResult) error {
	return x.ServerStream.SendMsg(m)
}

// BluetoothClassicService_ServiceDesc is the grpc.ServiceDesc for BluetoothClassicService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BluetoothClassicService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "worker.BluetoothClassicService",
	HandlerType: (*BluetoothClassicServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Scan",
			Handler:    _BluetoothClassicService_Scan_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ScanBackground",
			Handler:       _BluetoothClassicService_ScanBackground_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "worker.proto",
}

// BluetoothLEServiceClient is the client API for BluetoothLEService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BluetoothLEServiceClient interface {
	// Start a device scan of duration "time"
	Scan(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (*ScanResult, error)
	// Enable background scanning with a reporting interval of "time"
	ScanBackground(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (BluetoothLEService_ScanBackgroundClient, error)
	// Connect to a device
	Connect(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error)
	// Disconnect from a device
	Disconnect(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error)
	// list services for a device
	ListBLEServices(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLEServicesResult, error)
	// list characterisitcs for a service
	ListBLECharactersistics(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLECharactersisticsResult, error)
	// list descriptors for a characteristic
	ListBLEDescriptors(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLEDescriptorsResult, error)
	// read a descriptor
	ReadBLEDescriptor(ctx context.Context, in *Device, opts ...grpc.CallOption) (*BluetoothData, error)
	// write a descriptor
	WriteBLEDescriptor(ctx context.Context, in *BluetoothData, opts ...grpc.CallOption) (*StatusMessage, error)
	// subscribe to the notification emitted by a characteristic
	Subscribe(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error)
	// unsubscribe from a characteristic's notifications
	Unsubscribe(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error)
	// global method to receive all the subscribed notifications
	ReceiveNotifications(ctx context.Context, in *Empty, opts ...grpc.CallOption) (BluetoothLEService_ReceiveNotificationsClient, error)
	// global method to receive all the broadcasted data
	ReceiveBroadcasted(ctx context.Context, in *Empty, opts ...grpc.CallOption) (BluetoothLEService_ReceiveBroadcastedClient, error)
}

type bluetoothLEServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBluetoothLEServiceClient(cc grpc.ClientConnInterface) BluetoothLEServiceClient {
	return &bluetoothLEServiceClient{cc}
}

func (c *bluetoothLEServiceClient) Scan(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (*ScanResult, error) {
	out := new(ScanResult)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLEService/Scan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEServiceClient) ScanBackground(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (BluetoothLEService_ScanBackgroundClient, error) {
	stream, err := c.cc.NewStream(ctx, &BluetoothLEService_ServiceDesc.Streams[0], "/worker.BluetoothLEService/ScanBackground", opts...)
	if err != nil {
		return nil, err
	}
	x := &bluetoothLEServiceScanBackgroundClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BluetoothLEService_ScanBackgroundClient interface {
	Recv() (*ScanResult, error)
	grpc.ClientStream
}

type bluetoothLEServiceScanBackgroundClient struct {
	grpc.ClientStream
}

func (x *bluetoothLEServiceScanBackgroundClient) Recv() (*ScanResult, error) {
	m := new(ScanResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bluetoothLEServiceClient) Connect(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error) {
	out := new(StatusMessage)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLEService/Connect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEServiceClient) Disconnect(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error) {
	out := new(StatusMessage)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLEService/Disconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEServiceClient) ListBLEServices(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLEServicesResult, error) {
	out := new(ListBLEServicesResult)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLEService/ListBLEServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEServiceClient) ListBLECharactersistics(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLECharactersisticsResult, error) {
	out := new(ListBLECharactersisticsResult)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLEService/ListBLECharactersistics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEServiceClient) ListBLEDescriptors(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLEDescriptorsResult, error) {
	out := new(ListBLEDescriptorsResult)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLEService/ListBLEDescriptors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEServiceClient) ReadBLEDescriptor(ctx context.Context, in *Device, opts ...grpc.CallOption) (*BluetoothData, error) {
	out := new(BluetoothData)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLEService/ReadBLEDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEServiceClient) WriteBLEDescriptor(ctx context.Context, in *BluetoothData, opts ...grpc.CallOption) (*StatusMessage, error) {
	out := new(StatusMessage)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLEService/WriteBLEDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEServiceClient) Subscribe(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error) {
	out := new(StatusMessage)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLEService/Subscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEServiceClient) Unsubscribe(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error) {
	out := new(StatusMessage)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLEService/Unsubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEServiceClient) ReceiveNotifications(ctx context.Context, in *Empty, opts ...grpc.CallOption) (BluetoothLEService_ReceiveNotificationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &BluetoothLEService_ServiceDesc.Streams[1], "/worker.BluetoothLEService/ReceiveNotifications", opts...)
	if err != nil {
		return nil, err
	}
	x := &bluetoothLEServiceReceiveNotificationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BluetoothLEService_ReceiveNotificationsClient interface {
	Recv() (*BluetoothData, error)
	grpc.ClientStream
}

type bluetoothLEServiceReceiveNotificationsClient struct {
	grpc.ClientStream
}

func (x *bluetoothLEServiceReceiveNotificationsClient) Recv() (*BluetoothData, error) {
	m := new(BluetoothData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bluetoothLEServiceClient) ReceiveBroadcasted(ctx context.Context, in *Empty, opts ...grpc.CallOption) (BluetoothLEService_ReceiveBroadcastedClient, error) {
	stream, err := c.cc.NewStream(ctx, &BluetoothLEService_ServiceDesc.Streams[2], "/worker.BluetoothLEService/ReceiveBroadcasted", opts...)
	if err != nil {
		return nil, err
	}
	x := &bluetoothLEServiceReceiveBroadcastedClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BluetoothLEService_ReceiveBroadcastedClient interface {
	Recv() (*BluetoothData, error)
	grpc.ClientStream
}

type bluetoothLEServiceReceiveBroadcastedClient struct {
	grpc.ClientStream
}

func (x *bluetoothLEServiceReceiveBroadcastedClient) Recv() (*BluetoothData, error) {
	m := new(BluetoothData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BluetoothLEServiceServer is the server API for BluetoothLEService service.
// All implementations must embed UnimplementedBluetoothLEServiceServer
// for forward compatibility
type BluetoothLEServiceServer interface {
	// Start a device scan of duration "time"
	Scan(context.Context, *DeviceScan) (*ScanResult, error)
	// Enable background scanning with a reporting interval of "time"
	ScanBackground(*DeviceScan, BluetoothLEService_ScanBackgroundServer) error
	// Connect to a device
	Connect(context.Context, *Device) (*StatusMessage, error)
	// Disconnect from a device
	Disconnect(context.Context, *Device) (*StatusMessage, error)
	// list services for a device
	ListBLEServices(context.Context, *Device) (*ListBLEServicesResult, error)
	// list characterisitcs for a service
	ListBLECharactersistics(context.Context, *Device) (*ListBLECharactersisticsResult, error)
	// list descriptors for a characteristic
	ListBLEDescriptors(context.Context, *Device) (*ListBLEDescriptorsResult, error)
	// read a descriptor
	ReadBLEDescriptor(context.Context, *Device) (*BluetoothData, error)
	// write a descriptor
	WriteBLEDescriptor(context.Context, *BluetoothData) (*StatusMessage, error)
	// subscribe to the notification emitted by a characteristic
	Subscribe(context.Context, *Device) (*StatusMessage, error)
	// unsubscribe from a characteristic's notifications
	Unsubscribe(context.Context, *Device) (*StatusMessage, error)
	// global method to receive all the subscribed notifications
	ReceiveNotifications(*Empty, BluetoothLEService_ReceiveNotificationsServer) error
	// global method to receive all the broadcasted data
	ReceiveBroadcasted(*Empty, BluetoothLEService_ReceiveBroadcastedServer) error
	mustEmbedUnimplementedBluetoothLEServiceServer()
}

// UnimplementedBluetoothLEServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBluetoothLEServiceServer struct {
}

func (UnimplementedBluetoothLEServiceServer) Scan(context.Context, *DeviceScan) (*ScanResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Scan not implemented")
}
func (UnimplementedBluetoothLEServiceServer) ScanBackground(*DeviceScan, BluetoothLEService_ScanBackgroundServer) error {
	return status.Errorf(codes.Unimplemented, "method ScanBackground not implemented")
}
func (UnimplementedBluetoothLEServiceServer) Connect(context.Context, *Device) (*StatusMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedBluetoothLEServiceServer) Disconnect(context.Context, *Device) (*StatusMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedBluetoothLEServiceServer) ListBLEServices(context.Context, *Device) (*ListBLEServicesResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBLEServices not implemented")
}
func (UnimplementedBluetoothLEServiceServer) ListBLECharactersistics(context.Context, *Device) (*ListBLECharactersisticsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBLECharactersistics not implemented")
}
func (UnimplementedBluetoothLEServiceServer) ListBLEDescriptors(context.Context, *Device) (*ListBLEDescriptorsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBLEDescriptors not implemented")
}
func (UnimplementedBluetoothLEServiceServer) ReadBLEDescriptor(context.Context, *Device) (*BluetoothData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadBLEDescriptor not implemented")
}
func (UnimplementedBluetoothLEServiceServer) WriteBLEDescriptor(context.Context, *BluetoothData) (*StatusMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteBLEDescriptor not implemented")
}
func (UnimplementedBluetoothLEServiceServer) Subscribe(context.Context, *Device) (*StatusMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedBluetoothLEServiceServer) Unsubscribe(context.Context, *Device) (*StatusMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedBluetoothLEServiceServer) ReceiveNotifications(*Empty, BluetoothLEService_ReceiveNotificationsServer) error {
	return status.Errorf(codes.Unimplemented, "method ReceiveNotifications not implemented")
}
func (UnimplementedBluetoothLEServiceServer) ReceiveBroadcasted(*Empty, BluetoothLEService_ReceiveBroadcastedServer) error {
	return status.Errorf(codes.Unimplemented, "method ReceiveBroadcasted not implemented")
}
func (UnimplementedBluetoothLEServiceServer) mustEmbedUnimplementedBluetoothLEServiceServer() {}

// UnsafeBluetoothLEServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BluetoothLEServiceServer will
// result in compilation errors.
type UnsafeBluetoothLEServiceServer interface {
	mustEmbedUnimplementedBluetoothLEServiceServer()
}

func RegisterBluetoothLEServiceServer(s grpc.ServiceRegistrar, srv BluetoothLEServiceServer) {
	s.RegisterService(&BluetoothLEService_ServiceDesc, srv)
}

func _BluetoothLEService_Scan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceScan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServiceServer).Scan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLEService/Scan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServiceServer).Scan(ctx, req.(*DeviceScan))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLEService_ScanBackground_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeviceScan)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BluetoothLEServiceServer).ScanBackground(m, &bluetoothLEServiceScanBackgroundServer{stream})
}

type BluetoothLEService_ScanBackgroundServer interface {
	Send(*ScanResult) error
	grpc.ServerStream
}

type bluetoothLEServiceScanBackgroundServer struct {
	grpc.ServerStream
}

func (x *bluetoothLEServiceScanBackgroundServer) Send(m *ScanResult) error {
	return x.ServerStream.SendMsg(m)
}

func _BluetoothLEService_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServiceServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLEService/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServiceServer).Connect(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLEService_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServiceServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLEService/Disconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServiceServer).Disconnect(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLEService_ListBLEServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServiceServer).ListBLEServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLEService/ListBLEServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServiceServer).ListBLEServices(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLEService_ListBLECharactersistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServiceServer).ListBLECharactersistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLEService/ListBLECharactersistics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServiceServer).ListBLECharactersistics(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLEService_ListBLEDescriptors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServiceServer).ListBLEDescriptors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLEService/ListBLEDescriptors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServiceServer).ListBLEDescriptors(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLEService_ReadBLEDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServiceServer).ReadBLEDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLEService/ReadBLEDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServiceServer).ReadBLEDescriptor(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLEService_WriteBLEDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BluetoothData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServiceServer).WriteBLEDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLEService/WriteBLEDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServiceServer).WriteBLEDescriptor(ctx, req.(*BluetoothData))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLEService_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServiceServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLEService/Subscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServiceServer).Subscribe(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLEService_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServiceServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLEService/Unsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServiceServer).Unsubscribe(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLEService_ReceiveNotifications_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BluetoothLEServiceServer).ReceiveNotifications(m, &bluetoothLEServiceReceiveNotificationsServer{stream})
}

type BluetoothLEService_ReceiveNotificationsServer interface {
	Send(*BluetoothData) error
	grpc.ServerStream
}

type bluetoothLEServiceReceiveNotificationsServer struct {
	grpc.ServerStream
}

func (x *bluetoothLEServiceReceiveNotificationsServer) Send(m *BluetoothData) error {
	return x.ServerStream.SendMsg(m)
}

func _BluetoothLEService_ReceiveBroadcasted_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BluetoothLEServiceServer).ReceiveBroadcasted(m, &bluetoothLEServiceReceiveBroadcastedServer{stream})
}

type BluetoothLEService_ReceiveBroadcastedServer interface {
	Send(*BluetoothData) error
	grpc.ServerStream
}

type bluetoothLEServiceReceiveBroadcastedServer struct {
	grpc.ServerStream
}

func (x *bluetoothLEServiceReceiveBroadcastedServer) Send(m *BluetoothData) error {
	return x.ServerStream.SendMsg(m)
}

// BluetoothLEService_ServiceDesc is the grpc.ServiceDesc for BluetoothLEService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BluetoothLEService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "worker.BluetoothLEService",
	HandlerType: (*BluetoothLEServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Scan",
			Handler:    _BluetoothLEService_Scan_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _BluetoothLEService_Connect_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _BluetoothLEService_Disconnect_Handler,
		},
		{
			MethodName: "ListBLEServices",
			Handler:    _BluetoothLEService_ListBLEServices_Handler,
		},
		{
			MethodName: "ListBLECharactersistics",
			Handler:    _BluetoothLEService_ListBLECharactersistics_Handler,
		},
		{
			MethodName: "ListBLEDescriptors",
			Handler:    _BluetoothLEService_ListBLEDescriptors_Handler,
		},
		{
			MethodName: "ReadBLEDescriptor",
			Handler:    _BluetoothLEService_ReadBLEDescriptor_Handler,
		},
		{
			MethodName: "WriteBLEDescriptor",
			Handler:    _BluetoothLEService_WriteBLEDescriptor_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _BluetoothLEService_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _BluetoothLEService_Unsubscribe_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ScanBackground",
			Handler:       _BluetoothLEService_ScanBackground_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReceiveNotifications",
			Handler:       _BluetoothLEService_ReceiveNotifications_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReceiveBroadcasted",
			Handler:       _BluetoothLEService_ReceiveBroadcasted_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "worker.proto",
}

// WorkerServiceClient is the client API for WorkerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkerServiceClient interface {
	// information on the worker
	WorkerInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*WorkerConfig, error)
}

type workerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerServiceClient(cc grpc.ClientConnInterface) WorkerServiceClient {
	return &workerServiceClient{cc}
}

func (c *workerServiceClient) WorkerInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*WorkerConfig, error) {
	out := new(WorkerConfig)
	err := c.cc.Invoke(ctx, "/worker.WorkerService/WorkerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerServiceServer is the server API for WorkerService service.
// All implementations must embed UnimplementedWorkerServiceServer
// for forward compatibility
type WorkerServiceServer interface {
	// information on the worker
	WorkerInfo(context.Context, *Empty) (*WorkerConfig, error)
	mustEmbedUnimplementedWorkerServiceServer()
}

// UnimplementedWorkerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedWorkerServiceServer struct {
}

func (UnimplementedWorkerServiceServer) WorkerInfo(context.Context, *Empty) (*WorkerConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkerInfo not implemented")
}
func (UnimplementedWorkerServiceServer) mustEmbedUnimplementedWorkerServiceServer() {}

// UnsafeWorkerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerServiceServer will
// result in compilation errors.
type UnsafeWorkerServiceServer interface {
	mustEmbedUnimplementedWorkerServiceServer()
}

func RegisterWorkerServiceServer(s grpc.ServiceRegistrar, srv WorkerServiceServer) {
	s.RegisterService(&WorkerService_ServiceDesc, srv)
}

func _WorkerService_WorkerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).WorkerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.WorkerService/WorkerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).WorkerInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkerService_ServiceDesc is the grpc.ServiceDesc for WorkerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "worker.WorkerService",
	HandlerType: (*WorkerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WorkerInfo",
			Handler:    _WorkerService_WorkerInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "worker.proto",
}
