// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package worker

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BluetoothClassicClient is the client API for BluetoothClassic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BluetoothClassicClient interface {
	// Start a device scan of duration "time"
	Scan(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (*ScanResult, error)
	// Enable background scanning with a reporting interval of "time"
	ScanBackground(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (BluetoothClassic_ScanBackgroundClient, error)
}

type bluetoothClassicClient struct {
	cc grpc.ClientConnInterface
}

func NewBluetoothClassicClient(cc grpc.ClientConnInterface) BluetoothClassicClient {
	return &bluetoothClassicClient{cc}
}

func (c *bluetoothClassicClient) Scan(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (*ScanResult, error) {
	out := new(ScanResult)
	err := c.cc.Invoke(ctx, "/worker.BluetoothClassic/Scan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothClassicClient) ScanBackground(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (BluetoothClassic_ScanBackgroundClient, error) {
	stream, err := c.cc.NewStream(ctx, &BluetoothClassic_ServiceDesc.Streams[0], "/worker.BluetoothClassic/ScanBackground", opts...)
	if err != nil {
		return nil, err
	}
	x := &bluetoothClassicScanBackgroundClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BluetoothClassic_ScanBackgroundClient interface {
	Recv() (*ScanResult, error)
	grpc.ClientStream
}

type bluetoothClassicScanBackgroundClient struct {
	grpc.ClientStream
}

func (x *bluetoothClassicScanBackgroundClient) Recv() (*ScanResult, error) {
	m := new(ScanResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BluetoothClassicServer is the server API for BluetoothClassic service.
// All implementations must embed UnimplementedBluetoothClassicServer
// for forward compatibility
type BluetoothClassicServer interface {
	// Start a device scan of duration "time"
	Scan(context.Context, *DeviceScan) (*ScanResult, error)
	// Enable background scanning with a reporting interval of "time"
	ScanBackground(*DeviceScan, BluetoothClassic_ScanBackgroundServer) error
	mustEmbedUnimplementedBluetoothClassicServer()
}

// UnimplementedBluetoothClassicServer must be embedded to have forward compatible implementations.
type UnimplementedBluetoothClassicServer struct {
}

func (UnimplementedBluetoothClassicServer) Scan(context.Context, *DeviceScan) (*ScanResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Scan not implemented")
}
func (UnimplementedBluetoothClassicServer) ScanBackground(*DeviceScan, BluetoothClassic_ScanBackgroundServer) error {
	return status.Errorf(codes.Unimplemented, "method ScanBackground not implemented")
}
func (UnimplementedBluetoothClassicServer) mustEmbedUnimplementedBluetoothClassicServer() {}

// UnsafeBluetoothClassicServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BluetoothClassicServer will
// result in compilation errors.
type UnsafeBluetoothClassicServer interface {
	mustEmbedUnimplementedBluetoothClassicServer()
}

func RegisterBluetoothClassicServer(s grpc.ServiceRegistrar, srv BluetoothClassicServer) {
	s.RegisterService(&BluetoothClassic_ServiceDesc, srv)
}

func _BluetoothClassic_Scan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceScan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothClassicServer).Scan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothClassic/Scan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothClassicServer).Scan(ctx, req.(*DeviceScan))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothClassic_ScanBackground_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeviceScan)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BluetoothClassicServer).ScanBackground(m, &bluetoothClassicScanBackgroundServer{stream})
}

type BluetoothClassic_ScanBackgroundServer interface {
	Send(*ScanResult) error
	grpc.ServerStream
}

type bluetoothClassicScanBackgroundServer struct {
	grpc.ServerStream
}

func (x *bluetoothClassicScanBackgroundServer) Send(m *ScanResult) error {
	return x.ServerStream.SendMsg(m)
}

// BluetoothClassic_ServiceDesc is the grpc.ServiceDesc for BluetoothClassic service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BluetoothClassic_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "worker.BluetoothClassic",
	HandlerType: (*BluetoothClassicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Scan",
			Handler:    _BluetoothClassic_Scan_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ScanBackground",
			Handler:       _BluetoothClassic_ScanBackground_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "worker.proto",
}

// BluetoothLEClient is the client API for BluetoothLE service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BluetoothLEClient interface {
	// Start a device scan of duration "time"
	Scan(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (*ScanResult, error)
	// Enable background scanning with a reporting interval of "time"
	ScanBackground(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (BluetoothLE_ScanBackgroundClient, error)
	// Connect to a device
	Connect(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error)
	// Disconnect from a device
	Disconnect(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error)
	// list services for a device
	ListBLEServices(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLEServicesResult, error)
	// list characterisitcs for a service
	ListBLECharactersistics(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLECharactersisticsResult, error)
	// list descriptors for a characteristic
	ListBLEDescriptors(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLEDescriptorsResult, error)
	// read a descriptor
	ReadBLEDescriptor(ctx context.Context, in *Device, opts ...grpc.CallOption) (*BluetoothData, error)
	// write a descriptor
	WriteBLEDescriptor(ctx context.Context, in *BluetoothData, opts ...grpc.CallOption) (*StatusMessage, error)
	// subscribe to the notification emitted by a characteristic
	Subscribe(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error)
	// unsubscribe from a characteristic's notifications
	Unsubscribe(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error)
	// global method to receive all the subscribed notifications
	ReceiveNotifications(ctx context.Context, in *Empty, opts ...grpc.CallOption) (BluetoothLE_ReceiveNotificationsClient, error)
}

type bluetoothLEClient struct {
	cc grpc.ClientConnInterface
}

func NewBluetoothLEClient(cc grpc.ClientConnInterface) BluetoothLEClient {
	return &bluetoothLEClient{cc}
}

func (c *bluetoothLEClient) Scan(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (*ScanResult, error) {
	out := new(ScanResult)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLE/Scan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEClient) ScanBackground(ctx context.Context, in *DeviceScan, opts ...grpc.CallOption) (BluetoothLE_ScanBackgroundClient, error) {
	stream, err := c.cc.NewStream(ctx, &BluetoothLE_ServiceDesc.Streams[0], "/worker.BluetoothLE/ScanBackground", opts...)
	if err != nil {
		return nil, err
	}
	x := &bluetoothLEScanBackgroundClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BluetoothLE_ScanBackgroundClient interface {
	Recv() (*ScanResult, error)
	grpc.ClientStream
}

type bluetoothLEScanBackgroundClient struct {
	grpc.ClientStream
}

func (x *bluetoothLEScanBackgroundClient) Recv() (*ScanResult, error) {
	m := new(ScanResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bluetoothLEClient) Connect(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error) {
	out := new(StatusMessage)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLE/Connect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEClient) Disconnect(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error) {
	out := new(StatusMessage)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLE/Disconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEClient) ListBLEServices(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLEServicesResult, error) {
	out := new(ListBLEServicesResult)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLE/ListBLEServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEClient) ListBLECharactersistics(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLECharactersisticsResult, error) {
	out := new(ListBLECharactersisticsResult)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLE/ListBLECharactersistics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEClient) ListBLEDescriptors(ctx context.Context, in *Device, opts ...grpc.CallOption) (*ListBLEDescriptorsResult, error) {
	out := new(ListBLEDescriptorsResult)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLE/ListBLEDescriptors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEClient) ReadBLEDescriptor(ctx context.Context, in *Device, opts ...grpc.CallOption) (*BluetoothData, error) {
	out := new(BluetoothData)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLE/ReadBLEDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEClient) WriteBLEDescriptor(ctx context.Context, in *BluetoothData, opts ...grpc.CallOption) (*StatusMessage, error) {
	out := new(StatusMessage)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLE/WriteBLEDescriptor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEClient) Subscribe(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error) {
	out := new(StatusMessage)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLE/Subscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEClient) Unsubscribe(ctx context.Context, in *Device, opts ...grpc.CallOption) (*StatusMessage, error) {
	out := new(StatusMessage)
	err := c.cc.Invoke(ctx, "/worker.BluetoothLE/Unsubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothLEClient) ReceiveNotifications(ctx context.Context, in *Empty, opts ...grpc.CallOption) (BluetoothLE_ReceiveNotificationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &BluetoothLE_ServiceDesc.Streams[1], "/worker.BluetoothLE/ReceiveNotifications", opts...)
	if err != nil {
		return nil, err
	}
	x := &bluetoothLEReceiveNotificationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BluetoothLE_ReceiveNotificationsClient interface {
	Recv() (*BluetoothData, error)
	grpc.ClientStream
}

type bluetoothLEReceiveNotificationsClient struct {
	grpc.ClientStream
}

func (x *bluetoothLEReceiveNotificationsClient) Recv() (*BluetoothData, error) {
	m := new(BluetoothData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BluetoothLEServer is the server API for BluetoothLE service.
// All implementations must embed UnimplementedBluetoothLEServer
// for forward compatibility
type BluetoothLEServer interface {
	// Start a device scan of duration "time"
	Scan(context.Context, *DeviceScan) (*ScanResult, error)
	// Enable background scanning with a reporting interval of "time"
	ScanBackground(*DeviceScan, BluetoothLE_ScanBackgroundServer) error
	// Connect to a device
	Connect(context.Context, *Device) (*StatusMessage, error)
	// Disconnect from a device
	Disconnect(context.Context, *Device) (*StatusMessage, error)
	// list services for a device
	ListBLEServices(context.Context, *Device) (*ListBLEServicesResult, error)
	// list characterisitcs for a service
	ListBLECharactersistics(context.Context, *Device) (*ListBLECharactersisticsResult, error)
	// list descriptors for a characteristic
	ListBLEDescriptors(context.Context, *Device) (*ListBLEDescriptorsResult, error)
	// read a descriptor
	ReadBLEDescriptor(context.Context, *Device) (*BluetoothData, error)
	// write a descriptor
	WriteBLEDescriptor(context.Context, *BluetoothData) (*StatusMessage, error)
	// subscribe to the notification emitted by a characteristic
	Subscribe(context.Context, *Device) (*StatusMessage, error)
	// unsubscribe from a characteristic's notifications
	Unsubscribe(context.Context, *Device) (*StatusMessage, error)
	// global method to receive all the subscribed notifications
	ReceiveNotifications(*Empty, BluetoothLE_ReceiveNotificationsServer) error
	mustEmbedUnimplementedBluetoothLEServer()
}

// UnimplementedBluetoothLEServer must be embedded to have forward compatible implementations.
type UnimplementedBluetoothLEServer struct {
}

func (UnimplementedBluetoothLEServer) Scan(context.Context, *DeviceScan) (*ScanResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Scan not implemented")
}
func (UnimplementedBluetoothLEServer) ScanBackground(*DeviceScan, BluetoothLE_ScanBackgroundServer) error {
	return status.Errorf(codes.Unimplemented, "method ScanBackground not implemented")
}
func (UnimplementedBluetoothLEServer) Connect(context.Context, *Device) (*StatusMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedBluetoothLEServer) Disconnect(context.Context, *Device) (*StatusMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedBluetoothLEServer) ListBLEServices(context.Context, *Device) (*ListBLEServicesResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBLEServices not implemented")
}
func (UnimplementedBluetoothLEServer) ListBLECharactersistics(context.Context, *Device) (*ListBLECharactersisticsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBLECharactersistics not implemented")
}
func (UnimplementedBluetoothLEServer) ListBLEDescriptors(context.Context, *Device) (*ListBLEDescriptorsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBLEDescriptors not implemented")
}
func (UnimplementedBluetoothLEServer) ReadBLEDescriptor(context.Context, *Device) (*BluetoothData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadBLEDescriptor not implemented")
}
func (UnimplementedBluetoothLEServer) WriteBLEDescriptor(context.Context, *BluetoothData) (*StatusMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteBLEDescriptor not implemented")
}
func (UnimplementedBluetoothLEServer) Subscribe(context.Context, *Device) (*StatusMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedBluetoothLEServer) Unsubscribe(context.Context, *Device) (*StatusMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedBluetoothLEServer) ReceiveNotifications(*Empty, BluetoothLE_ReceiveNotificationsServer) error {
	return status.Errorf(codes.Unimplemented, "method ReceiveNotifications not implemented")
}
func (UnimplementedBluetoothLEServer) mustEmbedUnimplementedBluetoothLEServer() {}

// UnsafeBluetoothLEServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BluetoothLEServer will
// result in compilation errors.
type UnsafeBluetoothLEServer interface {
	mustEmbedUnimplementedBluetoothLEServer()
}

func RegisterBluetoothLEServer(s grpc.ServiceRegistrar, srv BluetoothLEServer) {
	s.RegisterService(&BluetoothLE_ServiceDesc, srv)
}

func _BluetoothLE_Scan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceScan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServer).Scan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLE/Scan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServer).Scan(ctx, req.(*DeviceScan))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLE_ScanBackground_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeviceScan)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BluetoothLEServer).ScanBackground(m, &bluetoothLEScanBackgroundServer{stream})
}

type BluetoothLE_ScanBackgroundServer interface {
	Send(*ScanResult) error
	grpc.ServerStream
}

type bluetoothLEScanBackgroundServer struct {
	grpc.ServerStream
}

func (x *bluetoothLEScanBackgroundServer) Send(m *ScanResult) error {
	return x.ServerStream.SendMsg(m)
}

func _BluetoothLE_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLE/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServer).Connect(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLE_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLE/Disconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServer).Disconnect(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLE_ListBLEServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServer).ListBLEServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLE/ListBLEServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServer).ListBLEServices(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLE_ListBLECharactersistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServer).ListBLECharactersistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLE/ListBLECharactersistics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServer).ListBLECharactersistics(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLE_ListBLEDescriptors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServer).ListBLEDescriptors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLE/ListBLEDescriptors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServer).ListBLEDescriptors(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLE_ReadBLEDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServer).ReadBLEDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLE/ReadBLEDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServer).ReadBLEDescriptor(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLE_WriteBLEDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BluetoothData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServer).WriteBLEDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLE/WriteBLEDescriptor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServer).WriteBLEDescriptor(ctx, req.(*BluetoothData))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLE_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLE/Subscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServer).Subscribe(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLE_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Device)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothLEServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.BluetoothLE/Unsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothLEServer).Unsubscribe(ctx, req.(*Device))
	}
	return interceptor(ctx, in, info, handler)
}

func _BluetoothLE_ReceiveNotifications_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BluetoothLEServer).ReceiveNotifications(m, &bluetoothLEReceiveNotificationsServer{stream})
}

type BluetoothLE_ReceiveNotificationsServer interface {
	Send(*BluetoothData) error
	grpc.ServerStream
}

type bluetoothLEReceiveNotificationsServer struct {
	grpc.ServerStream
}

func (x *bluetoothLEReceiveNotificationsServer) Send(m *BluetoothData) error {
	return x.ServerStream.SendMsg(m)
}

// BluetoothLE_ServiceDesc is the grpc.ServiceDesc for BluetoothLE service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BluetoothLE_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "worker.BluetoothLE",
	HandlerType: (*BluetoothLEServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Scan",
			Handler:    _BluetoothLE_Scan_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _BluetoothLE_Connect_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _BluetoothLE_Disconnect_Handler,
		},
		{
			MethodName: "ListBLEServices",
			Handler:    _BluetoothLE_ListBLEServices_Handler,
		},
		{
			MethodName: "ListBLECharactersistics",
			Handler:    _BluetoothLE_ListBLECharactersistics_Handler,
		},
		{
			MethodName: "ListBLEDescriptors",
			Handler:    _BluetoothLE_ListBLEDescriptors_Handler,
		},
		{
			MethodName: "ReadBLEDescriptor",
			Handler:    _BluetoothLE_ReadBLEDescriptor_Handler,
		},
		{
			MethodName: "WriteBLEDescriptor",
			Handler:    _BluetoothLE_WriteBLEDescriptor_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _BluetoothLE_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _BluetoothLE_Unsubscribe_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ScanBackground",
			Handler:       _BluetoothLE_ScanBackground_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReceiveNotifications",
			Handler:       _BluetoothLE_ReceiveNotifications_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "worker.proto",
}

// WorkerClient is the client API for Worker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkerClient interface {
	// information on the worker
	WorkerInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*WorkerConfig, error)
}

type workerClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerClient(cc grpc.ClientConnInterface) WorkerClient {
	return &workerClient{cc}
}

func (c *workerClient) WorkerInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*WorkerConfig, error) {
	out := new(WorkerConfig)
	err := c.cc.Invoke(ctx, "/worker.Worker/WorkerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerServer is the server API for Worker service.
// All implementations must embed UnimplementedWorkerServer
// for forward compatibility
type WorkerServer interface {
	// information on the worker
	WorkerInfo(context.Context, *Empty) (*WorkerConfig, error)
	mustEmbedUnimplementedWorkerServer()
}

// UnimplementedWorkerServer must be embedded to have forward compatible implementations.
type UnimplementedWorkerServer struct {
}

func (UnimplementedWorkerServer) WorkerInfo(context.Context, *Empty) (*WorkerConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkerInfo not implemented")
}
func (UnimplementedWorkerServer) mustEmbedUnimplementedWorkerServer() {}

// UnsafeWorkerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerServer will
// result in compilation errors.
type UnsafeWorkerServer interface {
	mustEmbedUnimplementedWorkerServer()
}

func RegisterWorkerServer(s grpc.ServiceRegistrar, srv WorkerServer) {
	s.RegisterService(&Worker_ServiceDesc, srv)
}

func _Worker_WorkerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).WorkerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worker.Worker/WorkerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).WorkerInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Worker_ServiceDesc is the grpc.ServiceDesc for Worker service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Worker_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "worker.Worker",
	HandlerType: (*WorkerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WorkerInfo",
			Handler:    _Worker_WorkerInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "worker.proto",
}
